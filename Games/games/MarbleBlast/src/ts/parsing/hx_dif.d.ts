/* tslint:disable */// Generated by Haxe TypeScript Declaration Generator :)

export class io_BytesReader {
	constructor(bytes: haxe_io_Bytes);
	readInt32(): number;
	readInt16(): number;
	readUInt16(): number;
	readByte(): number;
	readStr(): string;
	readFloat(): number;
	tell(): number;
	seek(pos: number): void;
}

export class AISpecialNode {
	constructor(name: string, position: math_Point3F);
	name: string;
	position: math_Point3F;
	static read(io: io_BytesReader): AISpecialNode;
}

export class AnimatedLight {
	constructor(nameIndex: number, stateIndex: number, stateCount: number, flags: number, duration: number);
	nameIndex: number;
	stateIndex: number;
	stateCount: number;
	flags: number;
	duration: number;
	static read(io: io_BytesReader): AnimatedLight;
}

export class BSPNode {
	constructor(planeIndex: number, frontIndex: number, backIndex: number, isFrontLeaf: boolean, isFrontSolid: boolean, isBackLeaf: boolean, isBackSolid: boolean);
	planeIndex: number;
	frontIndex: number;
	backIndex: number;
	isFrontLeaf: boolean;
	isFrontSolid: boolean;
	isBackLeaf: boolean;
	isBackSolid: boolean;
	static read(io: io_BytesReader, version: Version): BSPNode;
}

export class BSPSolidLeaf {
	constructor(surfaceStart: number, surfaceCount: number);
	surfaceStart: number;
	surfaceCount: number;
	static read(io: io_BytesReader): BSPSolidLeaf;
}

export class ConvexHull {
	constructor();
	hullStart: number;
	hullCount: number;
	minX: number;
	minY: number;
	minZ: number;
	maxX: number;
	maxY: number;
	maxZ: number;
	surfaceStart: number;
	surfaceCount: number;
	planeStart: number;
	polyListPlaneStart: number;
	polyListPointStart: number;
	polyListStringStart: number;
	staticMesh: boolean;
	static read(io: io_BytesReader, version: Version): ConvexHull;
}

export class CoordBin {
	constructor();
	binStart: number;
	binCount: number;
	static read(io: io_BytesReader): CoordBin;
}

export class Dif {
	constructor();
	difVersion: number;
	previewIncluded: number;
	interiors: Interior[];
	subObjects: Interior[];
	triggers: Trigger[];
	interiorPathfollowers: InteriorPathFollower[];
	forceFields: ForceField[];
	aiSpecialNodes: AISpecialNode[];
	vehicleCollision: VehicleCollision;
	gameEntities: GameEntity[];
	static LoadFromBuffer(buffer: haxe_io_Bytes): Dif;
	static LoadFromArrayBuffer(buffer: ArrayBuffer): Dif;
	static read(io: io_BytesReader): Dif;
}

export class Edge {
	constructor(pointIndex0: number, pointIndex1: number, surfaceIndex0: number, surfaceIndex1: number);
	pointIndex0: number;
	pointIndex1: number;
	surfaceIndex0: number;
	surfaceIndex1: number;
	static read(io: io_BytesReader, version: Version): Edge;
}

export class Edge2 {
	constructor();
	vertex0: number;
	vertex1: number;
	normal0: number;
	normal1: number;
	face0: number;
	face1: number;
	static read(io: io_BytesReader, version: Version): Edge2;
}

export class FFSurface {
	constructor();
	windingStart: number;
	windingCount: number;
	planeIndex: number;
	surfaceFlags: number;
	fanMask: number;
	static read(io: io_BytesReader): FFSurface;
}

export class ForceField {
	constructor();
	forceFieldFileVersion: number;
	name: string;
	triggers: string[];
	boundingBox: math_Box3F;
	boundingSphere: math_Spheref;
	normals: math_Point3F[];
	planes: Plane[];
	bspNodes: BSPNode[];
	bspSolidLeaves: BSPSolidLeaf[];
	windings: number[];
	surfaces: FFSurface[];
	solidLeafSurfaces: number[];
	color: number[];
	static read(io: io_BytesReader): ForceField;
}

/**
 * StringMap allows mapping of String keys to arbitrary values.
 * See `Map` for documentation details.
 * @see https://haxe.org/manual/std-Map.html
 */
export class haxe_ds_StringMap<T> extends Map<string, T> {
	/**
	 * Creates a new StringMap.
	 */
	constructor();
}

export class GameEntity {
	constructor();
	datablock: string;
	gameClass: string;
	position: math_Point3F;
	properties: haxe_ds_StringMap<string>;
	static read(io: io_BytesReader): GameEntity;
}

export class Interior {
	constructor();
	detailLevel: number;
	minPixels: number;
	boundingBox: math_Box3F;
	boundingSphere: math_Spheref;
	hasAlarmState: number;
	numLightStateEntries: number;
	normals: math_Point3F[];
	planes: Plane[];
	points: math_Point3F[];
	pointVisibilities: number[];
	texGenEQs: TexGenEQ[];
	bspNodes: BSPNode[];
	bspSolidLeaves: BSPSolidLeaf[];
	materialListVersion: number;
	materialList: string[];
	windings: number[];
	windingIndices: WindingIndex[];
	edges: Edge[];
	zones: Zone[];
	zoneSurfaces: number[];
	zoneStaticMeshes: number[];
	zonePortalList: number[];
	portals: Portal[];
	surfaces: Surface[];
	edges2: Edge2[];
	normals2: math_Point3F[];
	normalIndices: number[];
	normalLMapIndices: number[];
	alarmLMapIndices: number[];
	nullSurfaces: NullSurface[];
	lightMaps: LightMap[];
	solidLeafSurfaces: number[];
	animatedLights: AnimatedLight[];
	lightStates: LightState[];
	stateDatas: StateData[];
	stateDataFlags: number;
	stateDataBuffers: number[];
	nameBuffer: number[];
	subObjects: MirrorSubObject[];
	convexHulls: ConvexHull[];
	convexHullEmitStrings: number[];
	hullIndices: number[];
	hullPlaneIndices: number[];
	hullEmitStringIndices: number[];
	hullSurfaceIndices: number[];
	polyListPlanes: number[];
	polyListPoints: number[];
	polyListStrings: number[];
	coordBins: CoordBin[];
	coordBinIndices: number[];
	coordBinMode: number;
	baseAmbientColor: number[];
	alarmAmbientColor: number[];
	numStaticMeshes: number;
	texNormals: math_Point3F[];
	texMatrices: TexMatrix[];
	texMatIndices: number[];
	extendedLightMapData: number;
	lightMapBorderSize: number;
	static read(io: io_BytesReader, version: Version): Interior;
}

export class InteriorPathFollower {
	constructor();
	name: string;
	datablock: string;
	interiorResIndex: number;
	offset: math_Point3F;
	properties: haxe_ds_StringMap<string>;
	triggerId: number[];
	wayPoint: WayPoint[];
	totalMS: number;
	static read(io: io_BytesReader): InteriorPathFollower;
}

export class LightMap {
	constructor();
	lightmap: number[];
	lightdirmap: number[];
	keepLightMap: number;
	static read(io: io_BytesReader, version: Version): LightMap;
}

export class LightState {
	constructor(red: number, green: number, blue: number, activeTime: number, dataIndex: number, dataCount: number);
	red: number;
	green: number;
	blue: number;
	activeTime: number;
	dataIndex: number;
	dataCount: number;
	static read(io: io_BytesReader): LightState;
}

export class MirrorSubObject {
	constructor();
	detailLevel: number;
	zone: number;
	alphaLevel: number;
	surfaceCount: number;
	surfaceStart: number;
	centroid: math_Point3F;
	static read(io: io_BytesReader, version: Version): MirrorSubObject;
}

export class NullSurface {
	constructor();
	windingStart: number;
	planeIndex: number;
	surfaceFlags: number;
	windingCount: number;
	static read(io: io_BytesReader, version: Version): NullSurface;
}

export class Plane {
	constructor(normalIndex: number, planeDistance: number);
	normalIndex: number;
	planeDistance: number;
	static read(io: io_BytesReader): Plane;
}

export class Polyhedron {
	constructor();
	pointList: math_Point3F[];
	planeList: math_PlaneF[];
	edgeList: PolyhedronEdge[];
	static read(io: io_BytesReader): Polyhedron;
}

export class PolyhedronEdge {
	constructor(faceIndex0: number, faceIndex1: number, pointIndex0: number, pointIndex1: number);
	pointIndex0: number;
	pointIndex1: number;
	faceIndex0: number;
	faceIndex1: number;
	static read(io: io_BytesReader): PolyhedronEdge;
}

export class Portal {
	constructor(planeIndex: number, triFanCount: number, triFanStart: number, zoneFront: number, zoneBack: number);
	planeIndex: number;
	triFanCount: number;
	triFanStart: number;
	zoneFront: number;
	zoneBack: number;
	static read(io: io_BytesReader): Portal;
}

export class StateData {
	constructor(surfaceIndex: number, mapIndex: number, lightStateIndex: number);
	surfaceIndex: number;
	mapIndex: number;
	lightStateIndex: number;
	static read(io: io_BytesReader): StateData;
}

export class Surface {
	constructor();
	windingStart: number;
	windingCount: number;
	planeIndex: number;
	planeFlipped: boolean;
	textureIndex: number;
	texGenIndex: number;
	surfaceFlags: number;
	fanMask: number;
	lightMapFinalWord: number;
	lightMapTexGenXD: number;
	lightMapTexGenYD: number;
	lightCount: number;
	lightStateInfoStart: number;
	mapOffsetX: number;
	mapOffsetY: number;
	mapSizeX: number;
	mapSizeY: number;
	brushId: number;
	static read(io: io_BytesReader, version: Version, interior: Interior): Surface;
}

export class TexGenEQ {
	constructor();
	planeX: math_PlaneF;
	planeY: math_PlaneF;
	static read(io: io_BytesReader): TexGenEQ;
}

export class TexMatrix {
	constructor();
	t: number;
	n: number;
	b: number;
	static read(io: io_BytesReader): TexMatrix;
}

export class Trigger {
	constructor();
	name: string;
	datablock: string;
	properties: haxe_ds_StringMap<string>;
	polyhedron: Polyhedron;
	offset: math_Point3F;
	static read(io: io_BytesReader): Trigger;
}

export class VehicleCollision {
	constructor();
	vehicleCollisionFileVersion: number;
	convexHulls: ConvexHull[];
	convexHullEmitStrings: number[];
	hullIndices: number[];
	hullPlaneIndices: number[];
	hullEmitStringIndices: number[];
	hullSurfaceIndices: number[];
	polyListPlanes: number[];
	polyListPoints: number[];
	polyListStrings: number[];
	nullSurfaces: NullSurface[];
	points: math_Point3F[];
	planes: Plane[];
	windings: number[];
	windingIndices: WindingIndex[];
	static read(io: io_BytesReader, version: Version): VehicleCollision;
}

export class Version {
	constructor();
	difVersion: number;
	interiorVersion: number;
	interiorType: string;
	useLargeLightmaps: boolean;
}

export class WayPoint {
	constructor(position: math_Point3F, rotation: math_QuatF, msToNext: number, smoothingType: number);
	position: math_Point3F;
	rotation: math_QuatF;
	msToNext: number;
	smoothingType: number;
	static read(io: io_BytesReader): WayPoint;
}

export class WindingIndex {
	constructor(windingStart: number, windingCount: number);
	windingStart: number;
	windingCount: number;
	static read(io: io_BytesReader): WindingIndex;
}

export class Zone {
	constructor();
	portalStart: number;
	portalCount: number;
	surfaceStart: number;
	surfaceCount: number;
	staticMeshStart: number;
	staticMeshCount: number;
	flags: number;
	static read(io: io_BytesReader, version: Version): Zone;
}

export class haxe__Int64____Int64 {
	constructor(high: number, low: number);
	high: number;
	low: number;
}

export class haxe_io_Bytes {
	protected constructor(data: ArrayBuffer);
	readonly length: number;
	/**
	 * Returns the byte at index `pos`.
	 */
	get(pos: number): number;
	/**
	 * Stores the given byte `v` at the given position `pos`.
	 */
	set(pos: number, v: number): void;
	/**
	 * Copies `len` bytes from `src` into this instance.
	 * @param pos Zero-based location in `this` instance at which to start writing
	 * bytes.
	 * @param src Source `Bytes` instance from which to copy bytes.
	 * @param srcpos Zero-based location at `src` from which bytes will be copied.
	 * @param len Number of bytes to be copied.
	 */
	blit(pos: number, src: haxe_io_Bytes, srcpos: number, len: number): void;
	/**
	 * Sets `len` consecutive bytes starting from index `pos` of `this` instance
	 * to `value`.
	 */
	fill(pos: number, len: number, value: number): void;
	/**
	 * Returns a new `Bytes` instance that contains a copy of `len` bytes of
	 * `this` instance, starting at index `pos`.
	 */
	sub(pos: number, len: number): haxe_io_Bytes;
	/**
	 * Returns `0` if the bytes of `this` instance and the bytes of `other` are
	 * identical.
	 * Returns a negative value if the `length` of `this` instance is less than
	 * the `length` of `other`, or a positive value if the `length` of `this`
	 * instance is greater than the `length` of `other`.
	 * In case of equal `length`s, returns a negative value if the first different
	 * value in `other` is greater than the corresponding value in `this`
	 * instance; otherwise returns a positive value.
	 */
	compare(other: haxe_io_Bytes): number;
	/**
	 * Returns the IEEE double-precision value at the given position `pos` (in
	 * little-endian encoding). Result is unspecified if `pos` is outside the
	 * bounds.
	 */
	getDouble(pos: number): number;
	/**
	 * Returns the IEEE single-precision value at the given position `pos` (in
	 * little-endian encoding). Result is unspecified if `pos` is outside the
	 * bounds.
	 */
	getFloat(pos: number): number;
	/**
	 * Stores the given IEEE double-precision value `v` at the given position
	 * `pos` in little-endian encoding. Result is unspecified if writing outside
	 * of bounds.
	 */
	setDouble(pos: number, v: number): void;
	/**
	 * Stores the given IEEE single-precision value `v` at the given position
	 * `pos` in little-endian encoding. Result is unspecified if writing outside
	 * of bounds.
	 */
	setFloat(pos: number, v: number): void;
	/**
	 * Returns the 16-bit unsigned integer at the given position `pos` (in
	 * little-endian encoding).
	 */
	getUInt16(pos: number): number;
	/**
	 * Stores the given 16-bit unsigned integer `v` at the given position `pos`
	 * (in little-endian encoding).
	 */
	setUInt16(pos: number, v: number): void;
	/**
	 * Returns the 32-bit integer at the given position `pos` (in little-endian
	 * encoding).
	 */
	getInt32(pos: number): number;
	/**
	 * Stores the given 32-bit integer `v` at the given position `pos` (in
	 * little-endian encoding).
	 */
	setInt32(pos: number, v: number): void;
	/**
	 * Returns the 64-bit integer at the given position `pos` (in little-endian
	 * encoding).
	 */
	getInt64(pos: number): haxe__Int64____Int64;
	/**
	 * Stores the given 64-bit integer `v` at the given position `pos` (in
	 * little-endian encoding).
	 */
	setInt64(pos: number, v: haxe__Int64____Int64): void;
	/**
	 * Returns the `len`-bytes long string stored at the given position `pos`,
	 * interpreted with the given `encoding` (UTF-8 by default).
	 */
	getString(pos: number, len: number, encoding?: any): string;
	readString(pos: number, len: number): string;
	/**
	 * Returns a `String` representation of the bytes interpreted as UTF-8.
	 */
	toString(): string;
	/**
	 * Returns a hexadecimal `String` representation of the bytes of `this`
	 * instance.
	 */
	toHex(): string;
	/**
	 * Returns the bytes of `this` instance as `BytesData`.
	 */
	getData(): ArrayBuffer;
	/**
	 * Returns a new `Bytes` instance with the given `length`. The values of the
	 * bytes are not initialized and may not be zero.
	 */
	static alloc(length: number): haxe_io_Bytes;
	/**
	 * Returns the `Bytes` representation of the given `String`, using the
	 * specified encoding (UTF-8 by default).
	 */
	static ofString(s: string, encoding?: any): haxe_io_Bytes;
	/**
	 * Returns the `Bytes` representation of the given `BytesData`.
	 */
	static ofData(b: ArrayBuffer): haxe_io_Bytes;
	/**
	 * Converts the given hexadecimal `String` to `Bytes`. `s` must be a string of
	 * even length consisting only of hexadecimal digits. For example:
	 * `"0FDA14058916052309"`.
	 */
	static ofHex(s: string): haxe_io_Bytes;
	/**
	 * Reads the `pos`-th byte of the given `b` bytes, in the most efficient way
	 * possible. Behavior when reading outside of the available data is
	 * unspecified.
	 */
	static fastGet(b: ArrayBuffer, pos: number): number;
}

export class math_Box3F {
	constructor(minX: number, minY?: number, minZ?: number, maxX?: number, maxY?: number, maxZ?: number);
	minX: number;
	minY: number;
	minZ: number;
	maxX: number;
	maxY: number;
	maxZ: number;
	clone(): math_Box3F;
	center(): math_Point3F;
	extend(box: math_Box3F): void;
	Expand(point: math_Point3F): void;
	contains(p: math_Point3F): boolean;
	getClosestPoint(point: math_Point3F): math_Point3F;
	static PointBounds(point: math_Point3F, size: math_Point3F): math_Box3F;
	static read(io: io_BytesReader): math_Box3F;
}

export class math_PlaneF {
	constructor(x: number, y?: number, z?: number, d?: number);
	x: number;
	y: number;
	z: number;
	d: number;
	static ThreePoints(a: math_Point3F, b: math_Point3F, c: math_Point3F): math_PlaneF;
	static NormalD(normal: math_Point3F, d: number): math_PlaneF;
	static PointNormal(pt: math_Point3F, n: math_Point3F): math_PlaneF;
	static read(io: io_BytesReader): math_PlaneF;
}

export class math_Point3F {
	constructor(x: number, y?: number, z?: number);
	x: number;
	y: number;
	z: number;
	get(dim: number): number;
	set(dim: number, value: number): void;
	add(rhs: math_Point3F): math_Point3F;
	sub(rhs: math_Point3F): math_Point3F;
	scalar(rhs: number): math_Point3F;
	scalarDiv(rhs: number): math_Point3F;
	dot(rhs: math_Point3F): number;
	cross(rhs: math_Point3F): math_Point3F;
	length(): number;
	lengthSq(): number;
	normalized(): math_Point3F;
	equal(other: math_Point3F): boolean;
	copy(): math_Point3F;
	static read(io: io_BytesReader): math_Point3F;
}

export class math_Point4F {
	constructor();
	x: number;
	y: number;
	z: number;
	w: number;
	static read(io: io_BytesReader): math_Point4F;
}

export class math_QuatF {
	constructor();
	x: number;
	y: number;
	z: number;
	w: number;
	static read(io: io_BytesReader): math_QuatF;
}

export class math_Spheref {
	constructor();
	originX: number;
	originY: number;
	originZ: number;
	radius: number;
	static read(io: io_BytesReader): math_Spheref;
}