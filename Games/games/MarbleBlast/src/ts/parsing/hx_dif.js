// Generated by Haxe 4.3.1
(function ($hx_exports, $global) { "use strict";
$hx_exports["haxe"] = $hx_exports["haxe"] || {};
$hx_exports["haxe"]["io"] = $hx_exports["haxe"]["io"] || {};
$hx_exports["math"] = $hx_exports["math"] || {};
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class AISpecialNode {
	constructor(name,position) {
		this.name = name;
		this.position = position;
	}
	static read(io) {
		return new AISpecialNode(io.readStr(),math_Point3F.read(io));
	}
}
$hx_exports["AISpecialNode"] = AISpecialNode;
AISpecialNode.__name__ = true;
class AnimatedLight {
	constructor(nameIndex,stateIndex,stateCount,flags,duration) {
		this.nameIndex = nameIndex;
		this.stateIndex = stateIndex;
		this.stateCount = stateCount;
		this.flags = flags;
		this.duration = duration;
	}
	static read(io) {
		return new AnimatedLight(io.readInt32(),io.readInt32(),io.readInt16(),io.readInt16(),io.readInt32());
	}
}
$hx_exports["AnimatedLight"] = AnimatedLight;
AnimatedLight.__name__ = true;
class BSPNode {
	constructor(planeIndex,frontIndex,backIndex,isFrontLeaf,isFrontSolid,isBackLeaf,isBackSolid) {
		this.planeIndex = planeIndex;
		this.frontIndex = frontIndex;
		this.backIndex = backIndex;
		this.isFrontLeaf = isFrontLeaf;
		this.isFrontSolid = isFrontSolid;
		this.isBackLeaf = isBackLeaf;
		this.isBackSolid = isBackSolid;
	}
	static read(io,version) {
		let planeIndex = io.readUInt16();
		let frontIndex;
		let backIndex;
		let isfrontleaf = false;
		let isfrontsolid = false;
		let isbackleaf = false;
		let isbacksolid = false;
		if(version.interiorVersion >= 14) {
			frontIndex = io.readInt32();
			backIndex = io.readInt32();
			if((frontIndex & 524288) != 0) {
				frontIndex = frontIndex & -524289 | 32768;
				isfrontleaf = true;
			}
			if((frontIndex & 262144) != 0) {
				frontIndex = frontIndex & -262145 | 16384;
				isfrontsolid = true;
			}
			if((backIndex & 524288) != 0) {
				backIndex = backIndex & -524289 | 32768;
				isbackleaf = true;
			}
			if((backIndex & 262144) != 0) {
				backIndex = backIndex & -262145 | 16384;
				isbacksolid = true;
			}
		} else {
			frontIndex = io.readUInt16();
			backIndex = io.readUInt16();
			if((frontIndex & 32768) != 0) {
				isfrontleaf = true;
			}
			if((frontIndex & 16384) != 0) {
				isfrontsolid = true;
			}
			if((backIndex & 32768) != 0) {
				isbackleaf = true;
			}
			if((backIndex & 16384) != 0) {
				isbacksolid = true;
			}
		}
		return new BSPNode(planeIndex,frontIndex,backIndex,isfrontleaf,isfrontsolid,isbackleaf,isbacksolid);
	}
}
$hx_exports["BSPNode"] = BSPNode;
BSPNode.__name__ = true;
class BSPSolidLeaf {
	constructor(surfaceStart,surfaceCount) {
		this.surfaceStart = surfaceStart;
		this.surfaceCount = surfaceCount;
	}
	static read(io) {
		return new BSPSolidLeaf(io.readInt32(),io.readInt16());
	}
}
$hx_exports["BSPSolidLeaf"] = BSPSolidLeaf;
BSPSolidLeaf.__name__ = true;
class ConvexHull {
	constructor() {
		this.hullStart = 0;
		this.hullCount = 0;
		this.minX = 0;
		this.minY = 0;
		this.minZ = 0;
		this.maxX = 0;
		this.maxY = 0;
		this.maxZ = 0;
		this.surfaceStart = 0;
		this.surfaceCount = 0;
		this.planeStart = 0;
		this.polyListPlaneStart = 0;
		this.polyListPointStart = 0;
		this.polyListStringStart = 0;
		this.staticMesh = false;
	}
	static read(io,version) {
		let ret = new ConvexHull();
		ret.hullStart = io.readInt32();
		ret.hullCount = io.readUInt16();
		ret.minX = io.readFloat();
		ret.minY = io.readFloat();
		ret.minZ = io.readFloat();
		ret.maxX = io.readFloat();
		ret.maxY = io.readFloat();
		ret.maxZ = io.readFloat();
		ret.surfaceStart = io.readInt32();
		ret.surfaceCount = io.readUInt16();
		ret.planeStart = io.readInt32();
		ret.polyListPlaneStart = io.readInt32();
		ret.polyListPointStart = io.readInt32();
		ret.polyListStringStart = io.readInt32();
		if(version.interiorVersion >= 12) {
			ret.staticMesh = io.readByte() > 0;
		}
		return ret;
	}
}
$hx_exports["ConvexHull"] = ConvexHull;
ConvexHull.__name__ = true;
class CoordBin {
	constructor() {
		this.binStart = 0;
		this.binCount = 0;
	}
	static read(io) {
		let ret = new CoordBin();
		ret.binStart = io.readInt32();
		ret.binCount = io.readInt32();
		return ret;
	}
}
$hx_exports["CoordBin"] = CoordBin;
CoordBin.__name__ = true;
class Dif {
	constructor() {
		this.gameEntities = null;
		this.vehicleCollision = null;
	}
	static LoadFromBuffer(buffer) {
		let br = new io_BytesReader(buffer);
		return Dif.read(br);
	}
	static LoadFromArrayBuffer(buffer) {
		let br = new io_BytesReader(haxe_io_Bytes.ofData(buffer));
		return Dif.read(br);
	}
	static read(io) {
		let ret = new Dif();
		let version = new Version();
		version.difVersion = io.readInt32();
		ret.difVersion = version.difVersion;
		ret.previewIncluded = io.readByte();
		ret.interiors = ReaderExtensions.readArray(io,function(io) {
			return Interior.read(io,version);
		});
		ret.subObjects = ReaderExtensions.readArray(io,function(io) {
			return Interior.read(io,version);
		});
		ret.triggers = ReaderExtensions.readArray(io,Trigger.read);
		ret.interiorPathfollowers = ReaderExtensions.readArray(io,InteriorPathFollower.read);
		ret.forceFields = ReaderExtensions.readArray(io,ForceField.read);
		ret.aiSpecialNodes = ReaderExtensions.readArray(io,AISpecialNode.read);
		let readVehicleCollision = io.readInt32();
		if(readVehicleCollision == 1) {
			ret.vehicleCollision = VehicleCollision.read(io,version);
		}
		let readGameEntities = io.readInt32();
		if(readGameEntities == 2) {
			ret.gameEntities = ReaderExtensions.readArray(io,GameEntity.read);
		}
		return ret;
	}
}
$hx_exports["Dif"] = Dif;
Dif.__name__ = true;
class Edge {
	constructor(pointIndex0,pointIndex1,surfaceIndex0,surfaceIndex1) {
		this.pointIndex0 = pointIndex0;
		this.pointIndex1 = pointIndex1;
		this.surfaceIndex0 = surfaceIndex0;
		this.surfaceIndex1 = surfaceIndex1;
	}
	static read(io,version) {
		return new Edge(io.readInt32(),io.readInt32(),io.readInt32(),io.readInt32());
	}
}
$hx_exports["Edge"] = Edge;
Edge.__name__ = true;
class Edge2 {
	constructor() {
		this.vertex0 = 0;
		this.vertex1 = 0;
		this.normal0 = 0;
		this.normal1 = 0;
		this.face0 = 0;
		this.face1 = 0;
	}
	static read(io,version) {
		let ret = new Edge2();
		ret.vertex0 = io.readInt32();
		ret.vertex1 = io.readInt32();
		ret.normal0 = io.readInt32();
		ret.normal1 = io.readInt32();
		if(version.interiorVersion >= 3) {
			ret.face0 = io.readInt32();
			ret.face1 = io.readInt32();
		}
		return ret;
	}
}
$hx_exports["Edge2"] = Edge2;
Edge2.__name__ = true;
class FFSurface {
	constructor() {
		this.windingStart = 0;
		this.windingCount = 0;
		this.planeIndex = 0;
		this.surfaceFlags = 0;
		this.fanMask = 0;
	}
	static read(io) {
		let ret = new FFSurface();
		ret.windingStart = io.readInt32();
		ret.windingCount = io.readByte();
		ret.planeIndex = io.readInt16();
		ret.surfaceFlags = io.readByte();
		ret.fanMask = io.readInt32();
		return ret;
	}
}
$hx_exports["FFSurface"] = FFSurface;
FFSurface.__name__ = true;
class ForceField {
	constructor() {
	}
	static read(io) {
		let ret = new ForceField();
		ret.forceFieldFileVersion = io.readInt32();
		ret.name = io.readStr();
		ret.triggers = ReaderExtensions.readArray(io,function(io) {
			return io.readStr();
		});
		ret.boundingBox = math_Box3F.read(io);
		ret.boundingSphere = math_Spheref.read(io);
		ret.normals = ReaderExtensions.readArray(io,math_Point3F.read);
		ret.planes = ReaderExtensions.readArray(io,Plane.read);
		ret.bspNodes = ReaderExtensions.readArray(io,function(io) {
			return BSPNode.read(io,new Version());
		});
		ret.bspSolidLeaves = ReaderExtensions.readArray(io,BSPSolidLeaf.read);
		ret.windings = ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.surfaces = ReaderExtensions.readArray(io,FFSurface.read);
		ret.solidLeafSurfaces = ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.color = ReaderExtensions.readColorF(io);
		return ret;
	}
}
$hx_exports["ForceField"] = ForceField;
ForceField.__name__ = true;
class GameEntity {
	constructor() {
		this.datablock = "";
		this.gameClass = "";
		this.position = new math_Point3F();
		this.properties = new haxe_ds_StringMap();
	}
	static read(io) {
		let ret = new GameEntity();
		ret.datablock = io.readStr();
		ret.gameClass = io.readStr();
		ret.position = math_Point3F.read(io);
		ret.properties = ReaderExtensions.readDictionary(io);
		return ret;
	}
}
$hx_exports["GameEntity"] = GameEntity;
GameEntity.__name__ = true;
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = true;
class Interior {
	constructor() {
	}
	static read(io,version) {
		if(version.interiorType == "?") {
			version.interiorType = "tgea";
		}
		version.interiorVersion = io.readInt32();
		let it = new Interior();
		it.detailLevel = io.readInt32();
		it.minPixels = io.readInt32();
		it.boundingBox = math_Box3F.read(io);
		it.boundingSphere = math_Spheref.read(io);
		it.hasAlarmState = io.readByte();
		it.numLightStateEntries = io.readInt32();
		it.normals = ReaderExtensions.readArray(io,math_Point3F.read);
		it.planes = ReaderExtensions.readArray(io,Plane.read);
		it.points = ReaderExtensions.readArray(io,math_Point3F.read);
		if(version.interiorVersion == 4) {
			it.pointVisibilities = [];
		} else {
			it.pointVisibilities = ReaderExtensions.readArray(io,function(io) {
				return io.readByte();
			});
		}
		it.texGenEQs = ReaderExtensions.readArray(io,TexGenEQ.read);
		it.bspNodes = ReaderExtensions.readArray(io,function(io) {
			return BSPNode.read(io,version);
		});
		it.bspSolidLeaves = ReaderExtensions.readArray(io,BSPSolidLeaf.read);
		it.materialListVersion = io.readByte();
		it.materialList = ReaderExtensions.readArray(io,function(io) {
			return io.readStr();
		});
		it.windings = ReaderExtensions.readArrayAs(io,function(signed,param) {
			return param > 0;
		},function(io) {
			return io.readInt32();
		},function(io) {
			return io.readInt16();
		});
		it.windingIndices = ReaderExtensions.readArray(io,WindingIndex.read);
		if(version.interiorVersion >= 12) {
			it.edges = ReaderExtensions.readArray(io,function(io) {
				return Edge.read(io,version);
			});
		}
		it.zones = ReaderExtensions.readArray(io,function(io) {
			return Zone.read(io,version);
		});
		it.zoneSurfaces = ReaderExtensions.readArrayAs(io,function(signed,param) {
			return false;
		},function(io) {
			return io.readInt16();
		},function(io) {
			return io.readInt16();
		});
		if(version.interiorVersion >= 12) {
			it.zoneStaticMeshes = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
		}
		it.zonePortalList = ReaderExtensions.readArrayAs(io,function(signed,param) {
			return false;
		},function(io) {
			return io.readInt16();
		},function(io) {
			return io.readInt16();
		});
		it.portals = ReaderExtensions.readArray(io,Portal.read);
		let pos = io.tell();
		try {
			it.surfaces = ReaderExtensions.readArray(io,function(io) {
				return Surface.read(io,version,it);
			});
			if(version.interiorType == "?") {
				version.interiorType = "tge";
			}
		} catch( _g ) {
			if(version.interiorType == "tgea") {
				version.interiorType = "tge";
			}
			io.seek(pos);
			try {
				it.surfaces = ReaderExtensions.readArray(io,function(io) {
					return Surface.read(io,version,it);
				});
			} catch( _g ) {
				version.useLargeLightmaps = true;
				io.seek(pos);
				try {
					it.surfaces = ReaderExtensions.readArray(io,function(io) {
						return Surface.read(io,version,it);
					});
				} catch( _g ) {
					let e = haxe_Exception.caught(_g);
					throw haxe_Exception.thrown(e);
				}
			}
		}
		if(version.interiorVersion >= 2 && version.interiorVersion <= 5) {
			it.edges2 = ReaderExtensions.readArray(io,function(io) {
				return Edge2.read(io,version);
			});
			if(version.interiorVersion >= 4 && version.interiorVersion <= 5) {
				it.normals2 = ReaderExtensions.readArray(io,math_Point3F.read);
				it.normalIndices = ReaderExtensions.readArrayAs(io,function(alt,param) {
					if(alt) {
						return param == 0;
					} else {
						return false;
					}
				},function(io) {
					return io.readUInt16();
				},function(io) {
					return io.readByte();
				});
			}
		}
		if(version.interiorVersion == 4) {
			it.normalLMapIndices = ReaderExtensions.readArray(io,function(io) {
				return io.readByte();
			});
			it.alarmLMapIndices = [];
		} else if(version.interiorVersion >= 13) {
			it.normalLMapIndices = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
			it.alarmLMapIndices = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
		} else {
			it.normalLMapIndices = ReaderExtensions.readArray(io,function(io) {
				return io.readByte();
			});
			it.alarmLMapIndices = ReaderExtensions.readArray(io,function(io) {
				return io.readByte();
			});
		}
		it.nullSurfaces = ReaderExtensions.readArray(io,function(io) {
			return NullSurface.read(io,version);
		});
		if(version.interiorVersion != 4) {
			it.lightMaps = ReaderExtensions.readArray(io,function(io) {
				return LightMap.read(io,version);
			});
			if(it.lightMaps.length > 0 && version.interiorType == "mbg") {
				version.interiorType = "tge";
			}
		} else {
			it.lightMaps = [];
		}
		it.solidLeafSurfaces = ReaderExtensions.readArrayAs(io,function(alt,$void) {
			return alt;
		},function(io) {
			return io.readInt32();
		},function(io) {
			return io.readUInt16();
		});
		it.animatedLights = ReaderExtensions.readArray(io,AnimatedLight.read);
		it.lightStates = ReaderExtensions.readArray(io,LightState.read);
		if(version.interiorVersion == 4) {
			it.stateDatas = [];
			it.stateDataFlags = 0;
			it.stateDataBuffers = [];
			it.subObjects = [];
		} else {
			it.stateDatas = ReaderExtensions.readArray(io,StateData.read);
			it.stateDataBuffers = ReaderExtensions.readArrayFlags(io,function(io) {
				return io.readByte();
			});
			it.nameBuffer = ReaderExtensions.readArray(io,function(io) {
				return io.readByte();
			});
			it.stateDataFlags = 0;
			it.subObjects = ReaderExtensions.readArray(io,function(io) {
				let soKey = io.readInt32();
				if(soKey == 1) {
					return MirrorSubObject.read(io,version);
				} else {
					throw new haxe_Exception("Unknown SubObject key: ");
				}
			});
		}
		it.convexHulls = ReaderExtensions.readArray(io,function(io) {
			return ConvexHull.read(io,version);
		});
		it.convexHullEmitStrings = ReaderExtensions.readArray(io,function(io) {
			return io.readByte();
		});
		if(version.interiorVersion == 0) {
			it.hullIndices = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
		} else {
			it.hullIndices = ReaderExtensions.readArrayAs(io,function(alt,that) {
				return alt;
			},function(io) {
				return io.readInt32();
			},function(io) {
				return io.readUInt16();
			});
		}
		if(version.interiorVersion == 0) {
			it.hullPlaneIndices = ReaderExtensions.readArray(io,function(io) {
				return io.readUInt16();
			});
		} else {
			it.hullPlaneIndices = ReaderExtensions.readArrayAs(io,function(alt,that) {
				return true;
			},function(io) {
				return io.readInt32();
			},function(io) {
				return io.readUInt16();
			});
		}
		if(version.interiorVersion == 0) {
			it.hullEmitStringIndices = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
		} else {
			it.hullEmitStringIndices = ReaderExtensions.readArrayAs(io,function(alt,that) {
				return alt;
			},function(io) {
				return io.readInt32();
			},function(io) {
				return io.readUInt16();
			});
		}
		if(version.interiorVersion == 0) {
			it.hullSurfaceIndices = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
		} else {
			it.hullSurfaceIndices = ReaderExtensions.readArrayAs(io,function(alt,that) {
				return alt;
			},function(io) {
				return io.readInt32();
			},function(io) {
				return io.readUInt16();
			});
		}
		if(version.interiorVersion == 0) {
			it.polyListPlanes = ReaderExtensions.readArray(io,function(io) {
				return io.readUInt16();
			});
		} else {
			it.polyListPlanes = ReaderExtensions.readArrayAs(io,function(alt,that) {
				return true;
			},function(io) {
				return io.readInt32();
			},function(io) {
				return io.readUInt16();
			});
		}
		if(version.interiorVersion == 0) {
			it.polyListPoints = ReaderExtensions.readArray(io,function(io) {
				return io.readInt32();
			});
		} else {
			it.polyListPoints = ReaderExtensions.readArrayAs(io,function(alt,that) {
				return alt;
			},function(io) {
				return io.readInt32();
			},function(io) {
				return io.readUInt16();
			});
		}
		it.polyListStrings = ReaderExtensions.readArray(io,function(io) {
			return io.readByte();
		});
		it.coordBins = [];
		let _g = 0;
		while(_g < 256) {
			let i = _g++;
			it.coordBins.push(CoordBin.read(io));
		}
		it.coordBinIndices = ReaderExtensions.readArrayAs(io,function(a,b) {
			return true;
		},function(io) {
			return io.readUInt16();
		},function(io) {
			return io.readUInt16();
		});
		it.coordBinMode = io.readInt32();
		if(version.interiorVersion == 4) {
			it.baseAmbientColor = [0,0,0,255];
			it.alarmAmbientColor = [0,0,0,255];
			it.extendedLightMapData = 0;
			it.lightMapBorderSize = 0;
		} else {
			it.baseAmbientColor = ReaderExtensions.readColorF(io);
			it.alarmAmbientColor = ReaderExtensions.readColorF(io);
			if(version.interiorVersion >= 10) {
				it.numStaticMeshes = io.readInt32();
			}
			if(version.interiorVersion >= 11) {
				it.texNormals = ReaderExtensions.readArray(io,math_Point3F.read);
				it.texMatrices = ReaderExtensions.readArray(io,TexMatrix.read);
				it.texMatIndices = ReaderExtensions.readArray(io,function(io) {
					return io.readInt32();
				});
			} else {
				io.readInt32();
				io.readInt32();
				io.readInt32();
			}
			it.extendedLightMapData = io.readInt32();
			if(it.extendedLightMapData > 0) {
				it.lightMapBorderSize = io.readInt32();
				io.readInt32();
			}
		}
		return it;
	}
}
$hx_exports["Interior"] = Interior;
Interior.__name__ = true;
class InteriorPathFollower {
	constructor() {
		this.name = "";
		this.datablock = "";
		this.interiorResIndex = 0;
		this.offset = new math_Point3F();
		this.properties = new haxe_ds_StringMap();
		this.triggerId = [];
		this.wayPoint = [];
		this.totalMS = 0;
	}
	static read(io) {
		let ret = new InteriorPathFollower();
		ret.name = io.readStr();
		ret.datablock = io.readStr();
		ret.interiorResIndex = io.readInt32();
		ret.offset = math_Point3F.read(io);
		ret.properties = ReaderExtensions.readDictionary(io);
		ret.triggerId = ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.wayPoint = ReaderExtensions.readArray(io,WayPoint.read);
		ret.totalMS = io.readInt32();
		return ret;
	}
}
$hx_exports["InteriorPathFollower"] = InteriorPathFollower;
InteriorPathFollower.__name__ = true;
class LightMap {
	constructor() {
		this.lightmap = [];
		this.lightdirmap = [];
		this.keepLightMap = 0;
	}
	static read(io,version) {
		let ret = new LightMap();
		ret.lightmap = ReaderExtensions.readPNG(io);
		if(version.interiorType != "mbg" && version.interiorType != "tge") {
			ret.lightdirmap = ReaderExtensions.readPNG(io);
		}
		ret.keepLightMap = io.readByte();
		return ret;
	}
}
$hx_exports["LightMap"] = LightMap;
LightMap.__name__ = true;
class LightState {
	constructor(red,green,blue,activeTime,dataIndex,dataCount) {
		this.red = red;
		this.green = green;
		this.blue = blue;
		this.activeTime = activeTime;
		this.dataIndex = dataIndex;
		this.dataCount = dataCount;
	}
	static read(io) {
		return new LightState(io.readByte(),io.readByte(),io.readByte(),io.readInt32(),io.readInt32(),io.readInt16());
	}
}
$hx_exports["LightState"] = LightState;
LightState.__name__ = true;
Math.__name__ = true;
class MirrorSubObject {
	constructor() {
		this.detailLevel = 0;
		this.zone = 0;
		this.alphaLevel = 0;
		this.surfaceCount = 0;
		this.surfaceStart = 0;
		this.centroid = new math_Point3F();
	}
	static read(io,version) {
		let ret = new MirrorSubObject();
		ret.detailLevel = io.readInt32();
		ret.zone = io.readInt32();
		ret.alphaLevel = io.readFloat();
		ret.surfaceCount = io.readInt32();
		ret.surfaceStart = io.readInt32();
		ret.centroid = math_Point3F.read(io);
		return ret;
	}
}
$hx_exports["MirrorSubObject"] = MirrorSubObject;
MirrorSubObject.__name__ = true;
class NullSurface {
	constructor() {
		this.windingStart = 0;
		this.planeIndex = 0;
		this.surfaceFlags = 0;
		this.windingCount = 0;
	}
	static read(io,version) {
		let ret = new NullSurface();
		ret.windingStart = io.readInt32();
		ret.planeIndex = io.readUInt16();
		ret.surfaceFlags = io.readByte();
		if(version.interiorVersion >= 13) {
			ret.windingCount = io.readInt32();
		} else {
			ret.windingCount = io.readByte();
		}
		return ret;
	}
}
$hx_exports["NullSurface"] = NullSurface;
NullSurface.__name__ = true;
class Plane {
	constructor(normalIndex,planeDistance) {
		this.normalIndex = normalIndex;
		this.planeDistance = planeDistance;
	}
	static read(io) {
		return new Plane(io.readInt16(),io.readFloat());
	}
}
$hx_exports["Plane"] = Plane;
Plane.__name__ = true;
class Polyhedron {
	constructor() {
		this.pointList = [];
		this.planeList = [];
		this.edgeList = [];
	}
	static read(io) {
		let ret = new Polyhedron();
		ret.pointList = ReaderExtensions.readArray(io,math_Point3F.read);
		ret.planeList = ReaderExtensions.readArray(io,math_PlaneF.read);
		ret.edgeList = ReaderExtensions.readArray(io,PolyhedronEdge.read);
		return ret;
	}
}
$hx_exports["Polyhedron"] = Polyhedron;
Polyhedron.__name__ = true;
class PolyhedronEdge {
	constructor(faceIndex0,faceIndex1,pointIndex0,pointIndex1) {
		this.pointIndex0 = pointIndex0;
		this.pointIndex1 = pointIndex1;
		this.faceIndex0 = faceIndex0;
		this.faceIndex1 = faceIndex1;
	}
	static read(io) {
		return new PolyhedronEdge(io.readInt32(),io.readInt32(),io.readInt32(),io.readInt32());
	}
}
$hx_exports["PolyhedronEdge"] = PolyhedronEdge;
PolyhedronEdge.__name__ = true;
class Portal {
	constructor(planeIndex,triFanCount,triFanStart,zoneFront,zoneBack) {
		this.planeIndex = planeIndex;
		this.triFanCount = triFanCount;
		this.triFanStart = triFanStart;
		this.zoneFront = zoneFront;
		this.zoneBack = zoneBack;
	}
	static read(io) {
		return new Portal(io.readUInt16(),io.readUInt16(),io.readInt32(),io.readUInt16(),io.readUInt16());
	}
}
$hx_exports["Portal"] = Portal;
Portal.__name__ = true;
class ReaderExtensions {
	static readDictionary(io) {
		let len = io.readInt32();
		let dict = new haxe_ds_StringMap();
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			let name = io.readStr();
			let value = io.readStr();
			dict.h[name] = value;
		}
		return dict;
	}
	static readArray(io,readMethod) {
		let len = io.readInt32();
		let arr = [];
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			arr.push(readMethod(io));
		}
		return arr;
	}
	static readArrayAs(io,test,failMethod,passMethod) {
		let length = io.readInt32();
		let signed = false;
		let param = 0;
		if((length & -2147483648) == -2147483648) {
			length ^= -2147483648;
			signed = true;
			param = io.readByte();
		}
		let array = [];
		let _g = 0;
		let _g1 = length;
		while(_g < _g1) {
			let i = _g++;
			if(test(signed,param)) {
				array.push(passMethod(io));
			} else {
				array.push(failMethod(io));
			}
		}
		return array;
	}
	static readArrayFlags(io,readMethod) {
		let length = io.readInt32();
		let flags = io.readInt32();
		let array = [];
		let _g = 0;
		let _g1 = length;
		while(_g < _g1) {
			let i = _g++;
			array.push(readMethod(io));
		}
		return array;
	}
	static readPNG(io) {
		let footer = [73,69,78,68,174,66,96,130];
		let data = [];
		while(true) {
			data.push(io.readByte());
			if(data.length >= 8) {
				let match = true;
				let _g = 0;
				while(_g < 8) {
					let i = _g++;
					if(data[i + (data.length - 8)] != footer[i]) {
						match = false;
						break;
					}
				}
				if(match) {
					break;
				}
			}
		}
		return data;
	}
	static readColorF(io) {
		return [io.readByte(),io.readByte(),io.readByte(),io.readByte()];
	}
}
ReaderExtensions.__name__ = true;
class StateData {
	constructor(surfaceIndex,mapIndex,lightStateIndex) {
		this.surfaceIndex = surfaceIndex;
		this.mapIndex = mapIndex;
		this.lightStateIndex = lightStateIndex;
	}
	static read(io) {
		return new StateData(io.readInt32(),io.readInt32(),io.readInt16());
	}
}
$hx_exports["StateData"] = StateData;
StateData.__name__ = true;
class Surface {
	constructor() {
		this.windingStart = 0;
		this.windingCount = 0;
		this.planeIndex = 0;
		this.textureIndex = 0;
		this.texGenIndex = 0;
		this.surfaceFlags = 0;
		this.fanMask = 0;
		this.lightMapFinalWord = 0;
		this.lightMapTexGenXD = 0;
		this.lightMapTexGenYD = 0;
		this.lightCount = 0;
		this.lightStateInfoStart = 0;
		this.mapOffsetX = 0;
		this.mapOffsetY = 0;
		this.mapSizeX = 0;
		this.mapSizeY = 0;
		this.brushId = 0;
	}
	static read(io,version,interior) {
		let ret = new Surface();
		ret.windingStart = io.readInt32();
		if(interior.windings.length <= ret.windingStart) {
			throw new haxe_Exception("DIF Type Error interior.windings.length <= ret.windingStart");
		}
		if(version.interiorVersion >= 13) {
			ret.windingCount = io.readInt32();
		} else {
			ret.windingCount = io.readByte();
		}
		if(ret.windingStart + ret.windingCount > interior.windings.length) {
			throw new haxe_Exception("DIF Type Error ret.windingStart + ret.windingCount > interior.windings.length");
		}
		let planeIndex = io.readInt16();
		ret.planeFlipped = planeIndex >> 15 != 0;
		let planeIndexTemp = planeIndex & -32769;
		if((planeIndexTemp & -32769) >= interior.planes.length) {
			throw new haxe_Exception("DIF Type Error (planeIndexTemp & ~0x8000) >= interior.planes.length");
		}
		ret.planeIndex = planeIndexTemp;
		ret.textureIndex = io.readInt16();
		if(ret.textureIndex >= interior.materialList.length) {
			throw new haxe_Exception("DIF Type Error ret.textureIndex >= interior.materialList.length");
		}
		ret.texGenIndex = io.readInt32();
		if(ret.texGenIndex >= interior.texGenEQs.length) {
			throw new haxe_Exception("DIF Type Error ret.texGenIndex >= interior.texGenEQs.length");
		}
		ret.surfaceFlags = io.readByte();
		ret.fanMask = io.readInt32();
		ret.lightMapFinalWord = io.readInt16();
		ret.lightMapTexGenXD = io.readFloat();
		ret.lightMapTexGenYD = io.readFloat();
		ret.lightCount = io.readInt16();
		ret.lightStateInfoStart = io.readInt32();
		if(version.interiorVersion >= 13) {
			ret.mapOffsetX = io.readInt32();
			ret.mapOffsetY = io.readInt32();
			ret.mapSizeX = io.readInt32();
			ret.mapSizeY = io.readInt32();
		} else if(version.interiorVersion == 0 && version.interiorType == "tge" && version.useLargeLightmaps) {
			ret.mapOffsetX = io.readUInt16();
			ret.mapOffsetY = io.readUInt16();
			ret.mapSizeX = io.readUInt16();
			ret.mapSizeY = io.readUInt16();
		} else {
			ret.mapOffsetX = io.readByte();
			ret.mapOffsetY = io.readByte();
			ret.mapSizeX = io.readByte();
			ret.mapSizeY = io.readByte();
		}
		if(version.interiorType != "tge" && version.interiorType != "mbg") {
			io.readByte();
			if(version.interiorVersion >= 2 && version.interiorVersion <= 5) {
				ret.brushId = io.readInt32();
			}
		}
		return ret;
	}
}
$hx_exports["Surface"] = Surface;
Surface.__name__ = true;
class TexGenEQ {
	constructor() {
		this.planeX = new math_PlaneF();
		this.planeY = new math_PlaneF();
	}
	static read(io) {
		let ret = new TexGenEQ();
		ret.planeX = math_PlaneF.read(io);
		ret.planeY = math_PlaneF.read(io);
		return ret;
	}
}
$hx_exports["TexGenEQ"] = TexGenEQ;
TexGenEQ.__name__ = true;
class TexMatrix {
	constructor() {
		this.t = 0;
		this.n = 0;
		this.b = 0;
	}
	static read(io) {
		let ret = new TexMatrix();
		ret.t = io.readInt32();
		ret.n = io.readInt32();
		ret.b = io.readInt32();
		return ret;
	}
}
$hx_exports["TexMatrix"] = TexMatrix;
TexMatrix.__name__ = true;
class Trigger {
	constructor() {
		this.name = "";
		this.datablock = "";
		this.offset = new math_Point3F();
		this.properties = new haxe_ds_StringMap();
		this.polyhedron = new Polyhedron();
	}
	static read(io) {
		let ret = new Trigger();
		ret.name = io.readStr();
		ret.datablock = io.readStr();
		ret.properties = ReaderExtensions.readDictionary(io);
		ret.polyhedron = Polyhedron.read(io);
		ret.offset = math_Point3F.read(io);
		return ret;
	}
}
$hx_exports["Trigger"] = Trigger;
Trigger.__name__ = true;
class VehicleCollision {
	constructor() {
	}
	static read(io,version) {
		let ret = new VehicleCollision();
		ret.vehicleCollisionFileVersion = io.readInt32();
		ret.convexHulls = ReaderExtensions.readArray(io,function(io) {
			return ConvexHull.read(io,version);
		});
		ret.convexHullEmitStrings = ReaderExtensions.readArray(io,function(io) {
			return io.readByte();
		});
		ret.hullIndices = ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.hullPlaneIndices = ReaderExtensions.readArray(io,function(io) {
			return io.readInt16();
		});
		ret.hullEmitStringIndices = ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.hullSurfaceIndices = ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.polyListPlanes = ReaderExtensions.readArray(io,function(io) {
			return io.readInt16();
		});
		ret.polyListPoints = ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.polyListStrings = ReaderExtensions.readArray(io,function(io) {
			return io.readByte();
		});
		ret.nullSurfaces = ReaderExtensions.readArray(io,function(io) {
			return NullSurface.read(io,new Version());
		});
		ret.points = ReaderExtensions.readArray(io,math_Point3F.read);
		ret.planes = ReaderExtensions.readArray(io,Plane.read);
		ret.windings = ReaderExtensions.readArray(io,function(io) {
			return io.readInt32();
		});
		ret.windingIndices = ReaderExtensions.readArray(io,WindingIndex.read);
		return ret;
	}
}
$hx_exports["VehicleCollision"] = VehicleCollision;
VehicleCollision.__name__ = true;
class Version {
	constructor() {
		this.difVersion = 44;
		this.interiorVersion = 0;
		this.interiorType = "?";
		this.useLargeLightmaps = false;
	}
}
$hx_exports["Version"] = Version;
Version.__name__ = true;
class WayPoint {
	constructor(position,rotation,msToNext,smoothingType) {
		this.position = position;
		this.rotation = rotation;
		this.msToNext = msToNext;
		this.smoothingType = smoothingType;
	}
	static read(io) {
		return new WayPoint(math_Point3F.read(io),math_QuatF.read(io),io.readInt32(),io.readInt32());
	}
}
$hx_exports["WayPoint"] = WayPoint;
WayPoint.__name__ = true;
class WindingIndex {
	constructor(windingStart,windingCount) {
		this.windingStart = windingStart;
		this.windingCount = windingCount;
	}
	static read(io) {
		return new WindingIndex(io.readInt32(),io.readInt32());
	}
}
$hx_exports["WindingIndex"] = WindingIndex;
WindingIndex.__name__ = true;
class Zone {
	constructor() {
		this.portalStart = 0;
		this.portalCount = 0;
		this.surfaceStart = 0;
		this.surfaceCount = 0;
		this.staticMeshStart = 0;
		this.staticMeshCount = 0;
		this.flags = 0;
	}
	static read(io,version) {
		let ret = new Zone();
		ret.portalStart = io.readUInt16();
		ret.portalCount = io.readUInt16();
		ret.surfaceStart = io.readInt32();
		if(version.interiorType == "tgea" || version.interiorType == "tge") {
			if(version.interiorVersion >= 14 || version.interiorVersion == 0) {
				ret.surfaceCount = io.readUInt16();
			} else {
				ret.surfaceCount = io.readInt32();
			}
		} else {
			ret.surfaceCount = io.readInt32();
		}
		if(version.interiorVersion >= 12) {
			ret.staticMeshStart = io.readInt32();
			ret.staticMeshCount = io.readInt32();
		}
		if(version.interiorType == "tgea" || version.interiorType == "tge") {
			if(version.interiorVersion >= 14 || version.interiorVersion == 0) {
				ret.flags = io.readUInt16();
			}
		}
		return ret;
	}
}
$hx_exports["Zone"] = Zone;
Zone.__name__ = true;
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	toString() {
		return this.get_message();
	}
	get_message() {
		return this.message;
	}
	get_native() {
		return this.__nativeException;
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
haxe_Exception.__name__ = true;
class haxe__$Int64__$_$_$Int64 {
	constructor(high,low) {
		this.high = high;
		this.low = low;
	}
}
haxe__$Int64__$_$_$Int64.__name__ = true;
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
}
haxe_ValueException.__name__ = true;
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
}
haxe_ds_StringMap.__name__ = true;
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
	get(pos) {
		return this.b[pos];
	}
	set(pos,v) {
		this.b[pos] = v;
	}
	blit(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	fill(pos,len,value) {
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			this.b[pos++] = value;
		}
	}
	sub(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	compare(other) {
		let b1 = this.b;
		let b2 = other.b;
		let len = this.length < other.length ? this.length : other.length;
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			if(b1[i] != b2[i]) {
				return b1[i] - b2[i];
			}
		}
		return this.length - other.length;
	}
	initData() {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
	}
	getDouble(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat64(pos,true);
	}
	getFloat(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getFloat32(pos,true);
	}
	setDouble(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat64(pos,v,true);
	}
	setFloat(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setFloat32(pos,v,true);
	}
	getUInt16(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getUint16(pos,true);
	}
	setUInt16(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setUint16(pos,v,true);
	}
	getInt32(pos) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		return this.data.getInt32(pos,true);
	}
	setInt32(pos,v) {
		if(this.data == null) {
			this.data = new DataView(this.b.buffer,this.b.byteOffset,this.b.byteLength);
		}
		this.data.setInt32(pos,v,true);
	}
	getInt64(pos) {
		return new haxe__$Int64__$_$_$Int64(this.getInt32(pos + 4),this.getInt32(pos));
	}
	setInt64(pos,v) {
		this.setInt32(pos,v.low);
		this.setInt32(pos + 4,v.high);
	}
	getString(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		let s = "";
		let b = this.b;
		let i = pos;
		let max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			let debug = pos > 0;
			while(i < max) {
				let c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					let code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					let c2 = b[i++];
					let code = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else {
					let c2 = b[i++];
					let c3 = b[i++];
					let u = (c & 15) << 18 | (c2 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				let c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	readString(pos,len) {
		return this.getString(pos,len);
	}
	toString() {
		return this.getString(0,this.length);
	}
	toHex() {
		let s_b = "";
		let chars = [];
		let str = "0123456789abcdef";
		let _g = 0;
		let _g1 = str.length;
		while(_g < _g1) {
			let i = _g++;
			chars.push(HxOverrides.cca(str,i));
		}
		let _g2 = 0;
		let _g3 = this.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let c = this.b[i];
			s_b += String.fromCodePoint(chars[c >> 4]);
			s_b += String.fromCodePoint(chars[c & 15]);
		}
		return s_b;
	}
	getData() {
		return this.b.bufferValue;
	}
	static alloc(length) {
		return new haxe_io_Bytes(new ArrayBuffer(length));
	}
	static ofString(s,encoding) {
		if(encoding == haxe_io_Encoding.RawNative) {
			let buf = new Uint8Array(s.length << 1);
			let _g = 0;
			let _g1 = s.length;
			while(_g < _g1) {
				let i = _g++;
				let c = s.charCodeAt(i);
				buf[i << 1] = c & 255;
				buf[i << 1 | 1] = c >> 8;
			}
			return new haxe_io_Bytes(buf.buffer);
		}
		let a = [];
		let i = 0;
		while(i < s.length) {
			let c = s.charCodeAt(i++);
			if(55296 <= c && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
			}
			if(c <= 127) {
				a.push(c);
			} else if(c <= 2047) {
				a.push(192 | c >> 6);
				a.push(128 | c & 63);
			} else if(c <= 65535) {
				a.push(224 | c >> 12);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			} else {
				a.push(240 | c >> 18);
				a.push(128 | c >> 12 & 63);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			}
		}
		return new haxe_io_Bytes(new Uint8Array(a).buffer);
	}
	static ofData(b) {
		let hb = b.hxBytes;
		if(hb != null) {
			return hb;
		}
		return new haxe_io_Bytes(b);
	}
	static ofHex(s) {
		if((s.length & 1) != 0) {
			throw haxe_Exception.thrown("Not a hex string (odd number of digits)");
		}
		let a = [];
		let i = 0;
		let len = s.length >> 1;
		while(i < len) {
			let high = s.charCodeAt(i * 2);
			let low = s.charCodeAt(i * 2 + 1);
			high = (high & 15) + ((high & 64) >> 6) * 9;
			low = (low & 15) + ((low & 64) >> 6) * 9;
			a.push((high << 4 | low) & 255);
			++i;
		}
		return new haxe_io_Bytes(new Uint8Array(a).buffer);
	}
	static fastGet(b,pos) {
		return b.bytes[pos];
	}
}
$hx_exports["haxe"]["io"]["Bytes"] = haxe_io_Bytes;
haxe_io_Bytes.__name__ = true;
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
class io_BytesReader {
	constructor(bytes) {
		this.bytes = bytes;
		this.position = 0;
	}
	readInt32() {
		let b = this.bytes.getInt32(this.position);
		this.position += 4;
		return b;
	}
	readInt16() {
		let b = this.bytes.getUInt16(this.position);
		this.position += 2;
		return b;
	}
	readUInt16() {
		let b = this.bytes.getUInt16(this.position);
		this.position += 2;
		return b;
	}
	readByte() {
		let b = this.bytes.b[this.position];
		this.position += 1;
		return b;
	}
	readStr() {
		let len = this.readByte();
		let str = "";
		let reading = true;
		let _g = 0;
		let _g1 = len;
		while(_g < _g1) {
			let i = _g++;
			let ch = this.readByte();
			if(ch == 0) {
				reading = false;
			}
			if(reading) {
				str += String.fromCodePoint(ch);
			}
		}
		return str;
	}
	readFloat() {
		let b = this.bytes.getFloat(this.position);
		this.position += 4;
		return b;
	}
	tell() {
		return this.position;
	}
	seek(pos) {
		this.position = pos;
	}
}
io_BytesReader.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
class math_Box3F {
	constructor(minX,minY,minZ,maxX,maxY,maxZ) {
		if(maxZ == null) {
			maxZ = 0.0;
		}
		if(maxY == null) {
			maxY = 0.0;
		}
		if(maxX == null) {
			maxX = 0.0;
		}
		if(minZ == null) {
			minZ = 0.0;
		}
		if(minY == null) {
			minY = 0.0;
		}
		if(minX == null) {
			minX = 0.0;
		}
		this.minX = minX;
		this.minY = minY;
		this.minZ = minZ;
		this.maxX = maxX;
		this.maxY = maxY;
		this.maxZ = maxZ;
	}
	clone() {
		return new math_Box3F(this.minX,this.minY,this.minZ,this.maxX,this.maxY,this.maxZ);
	}
	center() {
		return new math_Point3F(this.minX + this.maxX,this.minY + this.maxY,this.minZ + this.maxZ).scalarDiv(2);
	}
	extend(box) {
		this.minX = Math.min(this.minX,box.minX);
		this.minY = Math.min(this.minY,box.minY);
		this.minZ = Math.min(this.minZ,box.minZ);
		this.maxX = Math.max(this.maxX,box.maxX);
		this.maxY = Math.max(this.maxY,box.maxY);
		this.maxZ = Math.max(this.maxZ,box.maxZ);
	}
	Expand(point) {
		if(this.minX > point.x) {
			this.minX = point.x;
		}
		if(this.minY > point.y) {
			this.minY = point.y;
		}
		if(this.minZ > point.z) {
			this.minZ = point.z;
		}
		if(this.maxX < point.x) {
			this.maxX = point.x;
		}
		if(this.maxY < point.y) {
			this.maxY = point.y;
		}
		if(this.maxZ < point.z) {
			this.maxZ = point.z;
		}
	}
	contains(p) {
		if(this.minX <= p.x && p.x <= this.maxX && this.minY <= p.y && p.y <= this.maxY && this.minZ <= p.z) {
			return p.z <= this.maxZ;
		} else {
			return false;
		}
	}
	getClosestPoint(point) {
		let closest = new math_Point3F();
		if(this.minX > point.x) {
			closest.x = this.minX;
		} else if(this.maxX < point.x) {
			closest.x = this.maxX;
		} else {
			closest.x = point.x;
		}
		if(this.minY > point.y) {
			closest.y = this.minY;
		} else if(this.maxY < point.y) {
			closest.y = this.maxY;
		} else {
			closest.y = point.y;
		}
		if(this.minZ > point.z) {
			closest.z = this.minZ;
		} else if(this.maxZ < point.z) {
			closest.z = this.maxZ;
		} else {
			closest.z = point.z;
		}
		return closest;
	}
	static PointBounds(point,size) {
		let ret = new math_Box3F();
		ret.minX = point.x;
		ret.minY = point.y;
		ret.minZ = point.z;
		ret.maxX = point.x + size.x;
		ret.maxY = point.y + size.y;
		ret.maxZ = point.z + size.z;
		return ret;
	}
	static read(io) {
		let ret = new math_Box3F();
		ret.minX = io.readFloat();
		ret.minY = io.readFloat();
		ret.minZ = io.readFloat();
		ret.maxX = io.readFloat();
		ret.maxY = io.readFloat();
		ret.maxZ = io.readFloat();
		return ret;
	}
}
$hx_exports["math"]["Box3F"] = math_Box3F;
math_Box3F.__name__ = true;
class math_PlaneF {
	constructor(x,y,z,d) {
		if(d == null) {
			d = 0.0;
		}
		if(z == null) {
			z = 0.0;
		}
		if(y == null) {
			y = 0.0;
		}
		if(x == null) {
			x = 0.0;
		}
		this.x = x;
		this.y = y;
		this.z = z;
		this.d = d;
	}
	static ThreePoints(a,b,c) {
		let v1 = a.sub(b);
		let v2 = c.sub(b);
		let res = v1.cross(v2);
		let ret = new math_PlaneF();
		let normal = res.normalized();
		ret.x = normal.x;
		ret.y = normal.y;
		ret.z = normal.z;
		ret.d = -b.dot(normal);
		return ret;
	}
	static NormalD(normal,d) {
		let ret = new math_PlaneF();
		ret.x = normal.x;
		ret.y = normal.y;
		ret.z = normal.z;
		ret.d = d;
		return ret;
	}
	static PointNormal(pt,n) {
		let ret = new math_PlaneF();
		let normal = n.normalized();
		ret.x = normal.x;
		ret.y = normal.y;
		ret.z = normal.z;
		ret.d = -pt.dot(normal);
		return ret;
	}
	static read(io) {
		let ret = new math_PlaneF();
		ret.x = io.readFloat();
		ret.y = io.readFloat();
		ret.z = io.readFloat();
		ret.d = io.readFloat();
		return ret;
	}
}
$hx_exports["math"]["PlaneF"] = math_PlaneF;
math_PlaneF.__name__ = true;
class math_Point3F {
	constructor(x,y,z) {
		if(z == null) {
			z = 0.0;
		}
		if(y == null) {
			y = 0.0;
		}
		if(x == null) {
			x = 0.0;
		}
		this.x = x;
		this.y = y;
		this.z = z;
	}
	get(dim) {
		if(dim == 0) {
			return this.x;
		}
		if(dim == 1) {
			return this.y;
		}
		if(dim == 2) {
			return this.z;
		}
		return -1;
	}
	set(dim,value) {
		if(dim == 0) {
			this.x = value;
		}
		if(dim == 1) {
			this.y = value;
		}
		if(dim == 2) {
			this.z = value;
		}
	}
	add(rhs) {
		return new math_Point3F(this.x + rhs.x,this.y + rhs.y,this.z + rhs.z);
	}
	sub(rhs) {
		return new math_Point3F(this.x - rhs.x,this.y - rhs.y,this.z - rhs.z);
	}
	scalar(rhs) {
		return new math_Point3F(this.x * rhs,this.y * rhs,this.z * rhs);
	}
	scalarDiv(rhs) {
		return new math_Point3F(this.x / rhs,this.y / rhs,this.z / rhs);
	}
	dot(rhs) {
		return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
	}
	cross(rhs) {
		return new math_Point3F(this.y * rhs.z - this.z * rhs.y,this.z * rhs.x - this.x * rhs.z,this.x * rhs.y - this.y * rhs.x);
	}
	length() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	}
	lengthSq() {
		return this.x * this.x + this.y * this.y + this.z * this.z;
	}
	normalized() {
		if(this.length() != 0) {
			return this.scalarDiv(this.length());
		} else {
			return this;
		}
	}
	equal(other) {
		if(this.x == other.x && this.y == other.y) {
			return this.z == other.z;
		} else {
			return false;
		}
	}
	copy() {
		return new math_Point3F(this.x,this.y,this.z);
	}
	static read(io) {
		let ret = new math_Point3F();
		ret.x = io.readFloat();
		ret.y = io.readFloat();
		ret.z = io.readFloat();
		return ret;
	}
}
$hx_exports["math"]["Point3F"] = math_Point3F;
math_Point3F.__name__ = true;
class math_Point4F {
	constructor() {
		this.x = 0;
		this.y = 0;
		this.z = 0;
		this.w = 0;
	}
	static read(io) {
		let ret = new math_Point4F();
		ret.x = io.readFloat();
		ret.y = io.readFloat();
		ret.z = io.readFloat();
		ret.w = io.readFloat();
		return ret;
	}
}
$hx_exports["math"]["Point4F"] = math_Point4F;
math_Point4F.__name__ = true;
class math_QuatF {
	constructor() {
		this.x = 0;
		this.y = 0;
		this.z = 0;
		this.w = 0;
	}
	static read(io) {
		let ret = new math_QuatF();
		ret.x = io.readFloat();
		ret.y = io.readFloat();
		ret.z = io.readFloat();
		ret.w = io.readFloat();
		return ret;
	}
}
$hx_exports["math"]["QuatF"] = math_QuatF;
math_QuatF.__name__ = true;
class math_Spheref {
	constructor() {
		this.originX = 0;
		this.originY = 0;
		this.originZ = 0;
		this.radius = 0;
	}
	static read(io) {
		let ret = new math_Spheref();
		ret.originX = io.readFloat();
		ret.originY = io.readFloat();
		ret.originZ = io.readFloat();
		ret.radius = io.readFloat();
		return ret;
	}
}
$hx_exports["math"]["Spheref"] = math_Spheref;
math_Spheref.__name__ = true;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
{
	String.__name__ = true;
	Array.__name__ = true;
}
js_Boot.__toStr = ({ }).toString;
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, {});
